# Stack & Queue

### 1. Stack &nbsp; [template](Stack_Queue/Stack.c)

### 2. Queue (Array) &nbsp; [template](Stack_Queue/Queue_Array.c)

### 3. Queue (Linked List) &nbsp; [template](Stack_Queue/Queue_LinkedList.c)

### 4. Priority Queue &nbsp; [template](Stack_Queue/Priority_Queue.c)

<br><br>


# Hash

### 1. Separate Chaining (Linked List) [template](Hash/Separate_Chaining.c)

### 2. Linear Probing [template](Hash/Linear_Probing.c)

### 3. Quadratic Probing

### 4. Double Hashing

<br><br>


# Tree Templates

### 1. Binary Search Tree &nbsp; [template](Tree/BinarySearchTree.c)

### 2. Max Heap  &nbsp; [template](Tree/MaxHeap.c)

### 3. NPL Leftist Tree &nbsp; [template](Tree/Leftist_Tree.c)

<br><br>


# Graph Algorithms

## Traversal Basic

### 1. BFS / DFS &nbsp; [template](Graph/Traversal_Basic/Adjacency_List,BFS,DFS.c)
- stack, queue
- adjacency list

### 2. Topological Sort &nbsp; [template](Graph/Traversal_Basic/Topological_Sort.c)
- Kann's Alogorithm, BFS
- check cycle by in-degree

### 3. Connected Component &nbsp; [template](Graph/Traversal_Basic/DisjointSetUnion.c)
- DSU(disjoint set union)

### 4. Bipartite Check
- check if the graph can be split into two groups
- every edge connects the other group

## Shortest Path

### 1. BFS (pathfinding) &nbsp; [template](Graph/Shortest_Path/BFS_pathfinding.c)
- unweighted grids
- output path using "parent method"

### 2. Dijkstra &nbsp; [template](Graph/Shortest_Path/Dijkstra.c)
- weighted graphs
- priority queue &nbsp; [template](Stack_Queue/Priority_Queue.c)
- max heap, min heap

### 3. Bellman-Ford

## Minimum Spanning Tree (MST)

### 1. Kruskal &nbsp; [template](Graph/Minimum_Spanning_Tree/Kruskal.c)
- Disjoint Set Union

### 2. Prim &nbsp; [template](Graph/Minimum_Spanning_Tree/Prim.c)
- binary heap
- Fibonacci heap

## Graph Structures

### 1. Union-Find
- Disjoint Set Union (DSU)

Cmd + Shift + V to preview